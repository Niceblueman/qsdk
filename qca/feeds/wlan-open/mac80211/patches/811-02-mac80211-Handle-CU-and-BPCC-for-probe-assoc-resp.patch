From eb8e880b21a8d06b8cffd90a41cf888f58b58955 Mon Sep 17 00:00:00 2001
From: Rathees Kumar R Chinannan <quic_rrchinan@quicinc.com>
Date: Tue, 8 Aug 2023 14:57:15 +0530
Subject: [PATCH] mac80211: Handle CU and BPCC for probe and assoc response

Add changes to indicate ongoing critical update CU flags,
BPCC values and CSA/CCA count in probe and assoc/reassoc response.
Extract cu_vdev_bitmap and bpcc values CU information from
TLV for probe and assoc / reassoc request.
Pass these values to mac80211.

Change-Id: Ifd48594fc1bc3f93d4c4f5b170481e886d0b3a11
Signed-off-by: Rathees Kumar R Chinannan <quic_rrchinan@quicinc.com>
---
 include/net/mac80211.h |  7 +++++++
 net/mac80211/cfg.c     | 36 +++++++++++++++++++++++++++++++++---
 net/mac80211/rx.c      | 13 ++++++++++++-
 net/mac80211/tx.c      |  5 +++++
 4 files changed, 57 insertions(+), 4 deletions(-)

diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 69bb3d9..61039f6 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -7573,4 +7573,11 @@ mesh_nss_offld_proxy_path_exp_update(struct ieee80211_vif *vif, u8* da,
 }
 #endif
 
+/** ieee80211_critical_update - update critical params for each link
+ * @vif: virtual interface
+ * @critical_flag: critical update information
+ * @bpcc: Bss parameter change count value
+ */
+void ieee80211_critical_update(struct ieee80211_vif *vif, unsigned int link_id,
+			       bool critical_flag, u8 bpcc);
 #endif /* MAC80211_H */
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index bb99dbc..c55fa7d 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -3873,6 +3873,7 @@ void ieee80211_csa_finish(struct ieee80211_vif *vif, unsigned int link_id)
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct ieee80211_local *local = sdata->local;
 	struct ieee80211_link_data *link;
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
 
 	if (WARN_ON(link_id > IEEE80211_MLD_MAX_NUM_LINKS))
 		return;
@@ -3885,6 +3886,10 @@ void ieee80211_csa_finish(struct ieee80211_vif *vif, unsigned int link_id)
 		return;
 	}
 
+	if (wdev->valid_links && (wdev->links[link_id].switch_count != 0)) {
+		wdev->links[link_id].switch_count = 0;
+		wdev->critical_update = 1;
+	}
 	if (link->conf->mbssid_tx_vif == vif &&
 	    link->conf->mbssid_tx_vif_linkid == link->conf->link_id) {
 		/* Trigger ieee80211_csa_finish() on the non-transmitting
@@ -3916,7 +3921,11 @@ void ieee80211_csa_finish(struct ieee80211_vif *vif, unsigned int link_id)
 				if (link_iter->conf->mbssid_tx_vif != vif ||
 				    link_iter->conf->mbssid_tx_vif_linkid != link->link_id)
 					continue;
-
+				if (iter->wdev.valid_links &&
+					(iter->wdev.links[link_id_iter].switch_count != 0)) {
+					iter->wdev.links[link_id_iter].switch_count = 0;
+					iter->wdev.critical_update = 1;
+				}
 				ieee80211_queue_work(&iter->local->hw,
 						     &link_iter->csa_finalize_work);
 			}
@@ -3928,6 +3937,24 @@ void ieee80211_csa_finish(struct ieee80211_vif *vif, unsigned int link_id)
 }
 EXPORT_SYMBOL(ieee80211_csa_finish);
 
+void ieee80211_critical_update(struct ieee80211_vif *vif, unsigned int link_id,
+			       bool critical_flag, u8 bpcc)
+{
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+
+	if (!wdev->valid_links)
+		return;
+	if (WARN_ON(link_id > IEEE80211_MLD_MAX_NUM_LINKS))
+		return;
+	if ((wdev->links[link_id].critical_flag != critical_flag) || (wdev->links[link_id].bpcc != bpcc)) {
+		wdev->critical_update = 1;
+		wdev->links[link_id].critical_flag = critical_flag;
+		wdev->links[link_id].bpcc = bpcc;
+	}
+
+}
+EXPORT_SYMBOL(ieee80211_critical_update);
+
 void ieee80211_channel_switch_disconnect(struct ieee80211_vif *vif, bool block_tx)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -5257,10 +5284,10 @@ void ieee80211_color_change_finish(struct ieee80211_vif *vif, unsigned int link_
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct ieee80211_link_data *link;
+	 struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
 
 	if (WARN_ON(link_id > IEEE80211_MLD_MAX_NUM_LINKS))
 		return;
-
 	rcu_read_lock();
 
 	link = rcu_dereference(sdata->link[link_id]);
@@ -5271,7 +5298,10 @@ void ieee80211_color_change_finish(struct ieee80211_vif *vif, unsigned int link_
 
 	ieee80211_queue_work(&sdata->local->hw,
 			     &link->color_change_finalize_work);
-
+	if (wdev->valid_links && (wdev->links[link_id].switch_count != 0)) {
+		wdev->links[link_id].switch_count = 0;
+		wdev->critical_update = 1;
+	}
 	rcu_read_unlock();
 }
 EXPORT_SYMBOL_GPL(ieee80211_color_change_finish);
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 4b6b3f4..46154b2 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -3871,14 +3871,25 @@ static ieee80211_rx_result debug_noinline
 ieee80211_rx_h_userspace_mgmt(struct ieee80211_rx_data *rx)
 {
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
+	struct ieee80211_mgmt *mgmt = (void *)rx->skb->data;
+	__le16 stype;
+	struct wireless_dev *wdev = &rx->sdata->wdev;
+
 	struct cfg80211_rx_info info = {
 		.freq = ieee80211_rx_status_to_khz(status),
 		.buf = rx->skb->data,
 		.len = rx->skb->len,
 		.link_id = rx->link_id,
 		.have_link_id = rx->link_id >= 0,
+		.critical_update = 0,
 	};
-
+	stype = mgmt->frame_control & cpu_to_le16(IEEE80211_FCTL_STYPE);
+	if ((stype ==  cpu_to_le16(IEEE80211_STYPE_PROBE_REQ)) ||
+	    (stype ==  cpu_to_le16(IEEE80211_STYPE_ASSOC_REQ)) ||
+	    (stype ==  cpu_to_le16(IEEE80211_STYPE_REASSOC_REQ))) {
+		if (wdev->critical_update)
+			info.critical_update = 1;
+	}
 	/* skip known-bad action frames and return them in the next handler */
 	if (status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM)
 		return RX_CONTINUE;
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 28b1550..1b4c5f0 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -5279,6 +5279,7 @@ u8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif, unsigned int link_i
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct ieee80211_link_data *link;
 	struct beacon_data *beacon = NULL;
+	 struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
 	u8 count = 0;
 
 	if (WARN_ON(link_id > IEEE80211_MLD_MAX_NUM_LINKS))
@@ -5301,6 +5302,10 @@ u8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif, unsigned int link_i
 		goto unlock;
 
 	count = __ieee80211_beacon_update_cntdwn(beacon);
+	if (wdev->valid_links && (wdev->links[link_id].switch_count != count)) {
+		wdev->links[link_id].switch_count = count;
+		wdev->critical_update = 1;
+	}
 
 unlock:
 	rcu_read_unlock();
-- 
2.17.1

