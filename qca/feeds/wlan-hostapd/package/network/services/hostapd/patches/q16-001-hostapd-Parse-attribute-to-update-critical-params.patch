From 6b22fbb88719d221919cbe497085fc5070ced391 Mon Sep 17 00:00:00 2001
From: Rathees Kumar R Chinannan <quic_rrchinan@quicinc.com>
Date: Tue, 8 Aug 2023 15:08:31 +0530
Subject: [PATCH] hostapd: Parse attribute to update critical params

Parse NL80211_ATTR_MLD_CRITICAL_UPDATE attribute to update
critical params on hostapd_data.

Change-Id: I90c709bfa27c4bda1d3441f52fcac7136efd3ba6
Signed-off-by: Rathees Kumar R Chinannan <quic_rrchinan@quicinc.com>
---
 src/drivers/driver_nl80211_event.c | 110 +++++++++++++++++++++++++++--
 src/drivers/nl80211_copy.h         |  72 +++++++++++++++++++
 2 files changed, 177 insertions(+), 5 deletions(-)

diff --git a/src/drivers/driver_nl80211_event.c b/src/drivers/driver_nl80211_event.c
index 49bab2c..7649caa 100644
--- a/src/drivers/driver_nl80211_event.c
+++ b/src/drivers/driver_nl80211_event.c
@@ -958,10 +958,104 @@ static struct i802_bss *mlme_route_mgmt_by_freq(struct i802_bss *bss, int freq)
 	return bss;
 }
 
+static void
+mlme_event_mgmt_critical_update(struct i802_bss *bss, struct nlattr *rx_cu_param)
+{
+	struct nlattr *cu[NL80211_CU_ATTR_MAX + 1];
+	struct nlattr *mld_list;
+	struct nlattr *mld[NL80211_CU_MLD_ATTR_MAX + 1];
+	struct nlattr *link_list;
+	struct nlattr *link[NL80211_CU_MLD_LINK_ATTR_MAX + 1];
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct i802_bss *link_bss, *tmp_bss;
+	union wpa_event_data event;
+	int rem,limit;
+	int ifidx = -1,mlo_link_id;
+
+	static struct nla_policy
+		link_policy[NL80211_CU_MLD_LINK_ATTR_MAX + 1] = {
+			[NL80211_CU_MLD_LINK_ATTR_ID] = { .type = NLA_U8 },
+			[NL80211_CU_MLD_LINK_ATTR_CRITICAL_FLAG] = { .type = NLA_FLAG },
+			[NL80211_CU_MLD_LINK_ATTR_BPCC] = { .type = NLA_U8 },
+			[NL80211_CU_MLD_LINK_ATTR_SWITCH_COUNT] = { .type = NLA_U8 },
+		};
+	static struct nla_policy
+		mld_policy[NL80211_CU_MLD_ATTR_MAX + 1] = {
+			[NL80211_CU_MLD_ATTR_IFINDEX] = { .type = NLA_U32 },
+			[NL80211_CU_MLD_ATTR_LINK_LIST] = { .type = NLA_NESTED },
+		};
+	static struct nla_policy
+		cu_policy[NL80211_CU_ATTR_MAX + 1] = {
+			[NL80211_CU_ATTR_MLD_LIST] = { .type = NLA_NESTED },
+		};
+
+	if (!rx_cu_param)
+		return;
+	nla_parse_nested(cu, NL80211_CU_ATTR_MAX, rx_cu_param, cu_policy);
+
+	nla_for_each_nested(mld_list, cu[NL80211_CU_ATTR_MLD_LIST], rem) {
+		if (nla_parse_nested(mld, NL80211_CU_MLD_ATTR_MAX,
+					mld_list, mld_policy)) {
+			return;
+		}
+		tmp_bss = NULL;
+		ifidx = -1;
+		if (mld[NL80211_CU_MLD_ATTR_IFINDEX]) {
+			ifidx = nla_get_u32(
+					mld[NL80211_CU_MLD_ATTR_IFINDEX]);
+			tmp_bss = get_bss_ifindex(drv, ifidx);
+			if (tmp_bss == NULL) {
+				wpa_printf(MSG_WARNING,
+					   "nl80211: Unknown ifindex (%d) for critical update",
+					   ifidx);
+				return;
+			}
+		}
+		if (tmp_bss && mld[NL80211_CU_MLD_ATTR_LINK_LIST]) {
+			nla_for_each_nested(link_list,
+					mld[NL80211_CU_MLD_ATTR_LINK_LIST],
+					limit) {
+				if (nla_parse_nested(link,
+							NL80211_CU_MLD_LINK_ATTR_MAX,
+							link_list, link_policy)) {
+					return;
+				}
+				os_memset(&event, 0, sizeof(event));
+				mlo_link_id = -1;
+				if (link[NL80211_CU_MLD_LINK_ATTR_ID]) {
+					mlo_link_id =
+						nla_get_u8(link[NL80211_CU_MLD_LINK_ATTR_ID]);
+					link_bss = get_link_bss_ifindex(tmp_bss, ifidx, mlo_link_id);
+					if (link_bss == NULL) {
+						wpa_printf(MSG_WARNING,
+								"nl80211: Unknown link_id (%d) for critical update",
+								mlo_link_id);
+						return;
+					}
+					event.cu_event.link_ctx = link_bss->ctx;
+
+					if (link[NL80211_CU_MLD_LINK_ATTR_CRITICAL_FLAG]) {
+						event.cu_event.critical_flag =
+							nla_get_flag(link[NL80211_CU_MLD_LINK_ATTR_CRITICAL_FLAG]);
+					}
+					if (link[NL80211_CU_MLD_LINK_ATTR_BPCC]) {
+						event.cu_event.bpcc =
+							nla_get_u8(link[NL80211_CU_MLD_LINK_ATTR_BPCC]);
+					}
+					if (link[NL80211_CU_MLD_LINK_ATTR_SWITCH_COUNT]) {
+						event.cu_event.switch_count =
+							nla_get_u8(link[NL80211_CU_MLD_LINK_ATTR_SWITCH_COUNT]);
+					}
+					wpa_supplicant_event(drv->ctx, EVENT_RX_CRITICAL_UPDATE, &event);
+				}
+			}
+		}
+	}
+}
 
 static void mlme_event_mgmt(struct i802_bss *bss,
 			    struct nlattr *freq, struct nlattr *sig,
-			    const u8 *frame, size_t len)
+			    const u8 *frame, size_t len, struct nlattr *rx_cu_param)
 {
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	const struct ieee80211_mgmt *mgmt;
@@ -999,6 +1093,10 @@ static void mlme_event_mgmt(struct i802_bss *bss,
 	event.rx_mgmt.frame_len = len;
 	event.rx_mgmt.ssi_signal = ssi_signal;
 	event.rx_mgmt.drv_priv = bss;
+	if (rx_cu_param && ((stype == WLAN_FC_STYPE_PROBE_REQ) || (stype == WLAN_FC_STYPE_ASSOC_REQ)
+	    || (stype == WLAN_FC_STYPE_REASSOC_REQ)))
+		mlme_event_mgmt_critical_update(bss, rx_cu_param);
+
 	wpa_supplicant_event(drv->ctx, EVENT_RX_MGMT, &event);
 }
 
@@ -1251,7 +1349,8 @@ static void mlme_event(struct i802_bss *bss,
 		       struct nlattr *addr, struct nlattr *timed_out,
 		       struct nlattr *freq, struct nlattr *ack,
 		       struct nlattr *cookie, struct nlattr *sig,
-		       struct nlattr *wmm, struct nlattr *req_ie)
+		       struct nlattr *wmm, struct nlattr *req_ie,
+		       struct nlattr *rx_cu_param)
 {
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	u16 stype = 0, auth_type = 0;
@@ -1359,7 +1458,7 @@ static void mlme_event(struct i802_bss *bss,
 		break;
 	case NL80211_CMD_FRAME:
 		mlme_event_mgmt(bss, freq, sig, nla_data(frame),
-				nla_len(frame));
+				nla_len(frame), rx_cu_param);
 		break;
 	case NL80211_CMD_FRAME_TX_STATUS:
 		mlme_event_mgmt_tx_status(bss, cookie, nla_data(frame),
@@ -3520,7 +3619,7 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 			   tb[NL80211_ATTR_COOKIE],
 			   tb[NL80211_ATTR_RX_SIGNAL_DBM],
 			   tb[NL80211_ATTR_STA_WME],
-			   tb[NL80211_ATTR_REQ_IE]);
+			   tb[NL80211_ATTR_REQ_IE], NULL);
 		break;
 	case NL80211_CMD_CONNECT:
 	case NL80211_CMD_ROAM:
@@ -3824,7 +3923,8 @@ int process_bss_event(struct nl_msg *msg, void *arg)
 			   tb[NL80211_ATTR_WIPHY_FREQ], tb[NL80211_ATTR_ACK],
 			   tb[NL80211_ATTR_COOKIE],
 			   tb[NL80211_ATTR_RX_SIGNAL_DBM],
-			   tb[NL80211_ATTR_STA_WME], NULL);
+			   tb[NL80211_ATTR_STA_WME], NULL,
+			   tb[NL80211_ATTR_RXMGMT_CRITICAL_UPDATE]);
 		break;
 	case NL80211_CMD_UNEXPECTED_FRAME:
 		nl80211_spurious_frame(bss, tb, 0);
diff --git a/src/drivers/nl80211_copy.h b/src/drivers/nl80211_copy.h
index 84b3f1b..40c756b 100644
--- a/src/drivers/nl80211_copy.h
+++ b/src/drivers/nl80211_copy.h
@@ -2776,6 +2776,10 @@ enum nl80211_commands {
  *	corresponds to the lowest 20MHZ channel. Each bit set to 1
  *	indicates that radar is detected in that sub-channel.
  *
+ * @NL80211_ATTR_RXMGMT_CRITICAL_UPDATE: Nested attribute listing the critical
+ *     update for each MLD. In each nested item, it contains attributes
+ *     defined in &enum nl80211_cu_attrs.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -3326,6 +3330,10 @@ enum nl80211_attrs {
 	NL80211_ATTR_MULTI_HW_MACS,
 	NL80211_ATTR_RADAR_BITMAP,
 	NL80211_ATTR_EHT_240MHZ_CAPABILITY,
+        NL80211_ATTR_ADD_MULTI_CHAN,
+        NL80211_ATTR_DEL_MULTI_CHAN,
+        NL80211_ATTR_RXMGMT_CRITICAL_UPDATE,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -7871,4 +7879,68 @@ enum nl80211_multi_hw_mac_chan_list_attrs {
 	NL80211_MULTI_HW_MAC_CHAN_LIST_ATTR_MAX =
 				__NL80211_MULTI_HW_MAC_CHAN_LIST_ATTR_LAST - 1,
 };
+
+/**
+ * nl80211_cu_attrs - critical update attributes
+ *
+ * @__NL80211_CU_ATTR_INVALID: invalid
+ * @NL80211_CU_ATTR_MLD_LIST: nested attribute specifying list of mld,
+ * see &enum nl80211_mld_list_cu_attrs
+ * @__NL80211_CU_ATTR_LAST: internal use
+ * @NL80211_CU_ATTR_MAX: maximum critical update attribute
+ */
+enum nl80211_cu_attrs {
+	__NL80211_CU_ATTR_INVALID,
+
+	NL80211_CU_ATTR_MLD_LIST,
+
+	/* keep last */
+	__NL80211_CU_ATTR_LAST,
+	NL80211_CU_ATTR_MAX = __NL80211_CU_ATTR_LAST - 1
+};
+
+/**
+ * nl80211_cu_mld_attrs - per mld critical update attributes
+ *
+ * @__NL80211_CU_MLD_ATTR_INVALID: invalid
+ * @NL80211_CU_MLD_ATTR_IFINDEX: network interface index of the device to operate on
+ * @NL80211_CU_MLD_ATTR_LINK_LIST: nested attribute specifying list of links
+ * on each mld, see &enum nl80211_cu_mld_link_attrs
+ * @__NL80211_CU_MLD_ATTR_LAST: internal use
+ * @NL80211_CU_MLD_ATTR_MAX: maximum per mld critical update attribute
+ */
+enum nl80211_cu_mld_attrs {
+	__NL80211_CU_MLD_ATTR_INVALID,
+
+	NL80211_CU_MLD_ATTR_IFINDEX,
+	NL80211_CU_MLD_ATTR_LINK_LIST,
+
+	/* keep last */
+	__NL80211_CU_MLD_ATTR_LAST,
+	NL80211_CU_MLD_ATTR_MAX = __NL80211_CU_MLD_ATTR_LAST - 1
+};
+
+/**
+ * nl80211_cu_mld_link_attrs - per link critical update attributes
+ *
+ * @__NL80211_CU_MLD_LINK_ATTR_INVALID: invalid
+ * @NL80211_CU_MLD_LINK_ATTR_ID: Link Id
+ * @NL80211_CU_MLD_LINK_ATTR_CRITICAL_FLAG: critical flag value
+ * @NL80211_CU_MLD_LINK_ATTR_BPCC: BSS parameter change count value
+ * @NL80211_CU_MLD_LINK_ATTR_SWITCH_COUNT: CSA/CCA switch count
+ * @__NL80211_CU_MLD_LINK_ATTR_LAST: internal use
+ * @NL80211_CU_MLD_LINK ATTR_MAX: maximum per link critical update attribute
+ */
+enum nl80211_cu_mld_link_attrs {
+	__NL80211_CU_MLD_LINK_ATTR_INVALID,
+
+	NL80211_CU_MLD_LINK_ATTR_ID,
+	NL80211_CU_MLD_LINK_ATTR_CRITICAL_FLAG,
+	NL80211_CU_MLD_LINK_ATTR_BPCC,
+	NL80211_CU_MLD_LINK_ATTR_SWITCH_COUNT,
+
+	/* keep last */
+	__NL80211_CU_MLD_LINK_ATTR_LAST,
+	NL80211_CU_MLD_LINK_ATTR_MAX = __NL80211_CU_MLD_LINK_ATTR_LAST - 1
+};
 #endif /* __LINUX_NL80211_H */
-- 
2.17.1

